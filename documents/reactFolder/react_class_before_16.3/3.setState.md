# setState
# setState
## 写这篇文章的初衷
> 1. react是采用单向数据流的形式，通过`state` -> 视图的更新
> 2. 优先处理上层`props`，通过`state`来维护状态值
> 3. `setState`是唯一触发state更新的api
> 4. 尽管`react-redux` 或者其他的状态库调用更新试图，本质都是通过`setState`
> 5. `setState`更新逻辑
> 6. 面试


## 同步异步问题
1. 使用pnpm + vite快速搭建一个react项目
2. 注意react版本是18.2


**那么react调用setState时候到底是同步还是异步？**


**代码**

```js

state = {
   num: 1
}
componentDidMount() {
    // this.setState({
    //   num: this.state.num + 1
    // });
    // this.setState({
    //   num: this.state.num + 1
    // });
    // this.setState({
    //   num: this.state.num + 3
    // });
    // setTimeout(() => {
    //   this.setState({
    //     num: this.state.num + 1
    //   });
    //   this.setState({
    //     num: this.state.num + 1
    //   });
    //   this.setState({
    //     num: this.state.num + 3
    //   });
    //   console.log(this.state.num);
    // });
    // console.log(this.state.num); //react版本 18.2 输出结果都是this.state.num ---> 1

    this.btnRef.addEventListener('click', this.nativeHandleClick, false);
  }
```
- 第一次页面加载效果

![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/89ca3dfa332b4c26a2e5e8d657fde514~tplv-k3u1fbpfcp-watermark.image?)

- 调试工具
打印两次是因为使用了StrictMode模式

![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f96b3d7261da4e38a6b9300323e470e8~tplv-k3u1fbpfcp-watermark.image?)

**在事件中触发会如何？**
```js

```
- 页面展示

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/05cf24c8657d4d9e97d21fa2ee563a4a~tplv-k3u1fbpfcp-watermark.image?)
- 调试器控制台

![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d43869d4fbaa419e956b8a9abe69005c~tplv-k3u1fbpfcp-watermark.image?)

```js
//react合成事件
handleClick = () => {
    this.setState(
      {
        num: this.state.num + 1
      },
      () => {
        console.log(this.state.num, '第1次'); //7
      }
    );
    this.setState(
      {
        num: this.state.num + 1
      },
      () => {
        console.log(this.state.num, '第2次'); //7
      }
    );
    this.setState(
      {
        num: this.state.num + 3
      },
      () => {
        console.log(this.state.num, '第3次'); //7
      }
    );

    console.log(this.state.num); // react版本 18.2 输出依然是4
  };
  //dom 原生事件
  //this.btnRef.addEventListener('click', this.nativeHandleClick, false);
  nativeHandleClick = () => {
    this.setState({
      num: this.state.num + 1
    });
    this.setState({
      num: this.state.num + 1
    });
    this.setState({
      num: this.state.num + 3
    });

    console.log(this.state.num); // react版本 18.2 输出依然是4
  };
```

> 1. react通过setState更新state，这个过程是一个异步调用过程，这中间包括react生命周期、react合成事件、浏览器宏任务例如setTimeout中调用都是异步触发。
> 2. react通过setState以函数形式更新，接收一个函数或者第二个回调函数可以接收到更新之后的最新值如上图
> 3. 补充： react18版本之前setState在setTimeout或者原生dom事件响应是同步的,这里引入[`react`17.0.2版本测试](https://github.com/chrisworkalx/js_frame_work/blob/develop/react%E7%B3%BB%E5%88%97/react-setState/react%4017.html)



## 更新逻辑

**流程图**


![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b0569154b8594c4391c65ca0d88b9e7d~tplv-k3u1fbpfcp-watermark.image?)


源码选择的 React 版本为`15.6.2`

### 基于React.Class类组件

```
ReactComponent.prototype.setState = function (partialState, callback) {
  this.updater.enqueueSetState(this, partialState)
  if (callback) {
    this.updater.enqueueCallback(this, callback, 'setState')
  }
}
```

### enqueueSetState

```js
enqueueSetState: function(publicInstance, partialState) {
  // 拿到对应的组件实例
  var internalInstance = getInternalInstanceReadyForUpdate(
    publicInstance,
    'setState',
  );
  // queue 对应一个组件实例的 state 数组
  var queue = internalInstance._pendingStateQueue || (internalInstance._pendingStateQueue = []);
  queue.push(partialState); // 将 partialState 放入待更新 state 队列
  // 处理当前的组件实例
  enqueueUpdate(internalInstance);
}
```

`_pendingStateQueue`表示待更新队列

`enqueueSetState` 做了两件事：

-   将新的 state 放进组件的状态队列里；
-   用 enqueueUpdate 来处理将要更新的实例对象。

### enqueueUpdate

```
function enqueueUpdate(component) {
  ensureInjected()
  // isBatchingUpdates 标识着当前是否处于批量更新过程
  if (!batchingStrategy.isBatchingUpdates) {
    // 若当前没有处于批量创建/更新组件的阶段，则立即更新组件
    batchingStrategy.batchedUpdates(enqueueUpdate, component)
    return
  }
  // 需要批量更新，则先把组件塞入 dirtyComponents 队列
  dirtyComponents.push(component)
  if (component._updateBatchNumber == null) {
    component._updateBatchNumber = updateBatchNumber + 1
  }
}
```

`batchingStrategy` 表示批量更新策略，`isBatchingUpdates`表示当前是否处于批量更新过程，默认是 false。

### batchingStrategy
```js
/**
 *  batchingStrategy源码
 **/
var ReactDefaultBatchingStrategy = {
  isBatchingUpdates: false, // 初始值为 false 表示当前并未进行任何批量更新操作

  // 发起更新动作的方法
  batchedUpdates: function (callback, a, b, c, d, e) {
    var alreadyBatchingUpdates = ReactDefaultBatchingStrategy.isBatchingUpdates

    ReactDefaultBatchingStrategy.isBatchingUpdates = true

    if (alreadyBatchingUpdates) {
      return callback(a, b, c, d, e)
    } else {
      // 启动事务，将 callback 放进事务里执行
      return transaction.perform(callback, null, a, b, c, d, e)
    }
  },
}
```

**每当 React 调用 batchedUpdate 去执行更新动作时，会先把`isBatchingUpdates`置为 true，表明正处于批量更新过程中。**

看完批量更新整体的管理机制，发现还有一个操作是`transaction.perform`，这就引出 React 中的 Transaction（事务）机制。

### transaction

```js
 * <pre>
 *                       wrappers (injected at creation time)
 *                                      +        +
 *                                      |        |
 *                    +-----------------|--------|--------------+
 *                    |                 v        |              |
 *                    |      +---------------+   |              |
 *                    |   +--|    wrapper1   |---|----+         |
 *                    |   |  +---------------+   v    |         |
 *                    |   |          +-------------+  |         |
 *                    |   |     +----|   wrapper2  |--------+   |
 *                    |   |     |    +-------------+  |     |   |
 *                    |   |     |                     |     |   |
 *                    |   v     v                     v     v   | wrapper
 *                    | +---+ +---+   +---------+   +---+ +---+ | invariants
 * perform(anyMethod) | |   | |   |   |         |   |   | |   | | maintained
 * +----------------->|-|---|-|---|-->|anyMethod|---|---|-|---|-|-------->
 *                    | |   | |   |   |         |   |   | |   | |
 *                    | |   | |   |   |         |   |   | |   | |
 *                    | |   | |   |   |         |   |   | |   | |
 *                    | +---+ +---+   +---------+   +---+ +---+ |
 *                    |  initialize                    close    |
 *                    +-----------------------------------------+
 * </pre>
```

>根据以上注释，可以看出：一个 Transaction 就是将需要执行的 method 使用 wrapper（一组 initialize 及 close 方法称为一个 wrapper） 封装起来，再通过 Transaction 提供的 perform 方法执行。

>在 perform 之前，先执行所有 wrapper 中的 initialize 方法；perform 完成之后（即 method 执行后）再执行所有的 close 方法，而且 Transaction 支持多个 wrapper 叠加。这就是 React 中的事务机制。

### batchingStrategy 批量更新策略

```js
var RESET_BATCHED_UPDATES = {
  initialize: emptyFunction,
  close: function () {
    ReactDefaultBatchingStrategy.isBatchingUpdates = false
  },
}
//  flushBatchedUpdates 将所有的临时 state 合并并计算出最新的 props 及 state
var FLUSH_BATCHED_UPDATES = {
  initialize: emptyFunction,
  close: ReactUpdates.flushBatchedUpdates.bind(ReactUpdates),
}

var TRANSACTION_WRAPPERS = [FLUSH_BATCHED_UPDATES, RESET_BATCHED_UPDATES]
```

>这两个wrapper的`initialize`都没有做什么事情，但是在callback执行完之后，`RESET_BATCHED_UPDATES` 的作用是将`isBatchingUpdates`置为false, `FLUSH_BATCHED_UPDATES` 的作用是执行`flushBatchedUpdates`,然后里面会循环所有`dirtyComponent`,调用`updateComponent`来执行所有的生命周期方法，`componentWillReceiveProps, shouldComponentUpdate, componentWillUpdate, render, componentDidUpdate` 最后实现组件的更新。

### react 生命周期钩子函数
```
// ReactMount.js
_renderNewRootComponent: function( nextElement, container, shouldReuseMarkup, context ) {
  // 实例化组件
  var componentInstance = instantiateReactComponent(nextElement);
  // 调用 batchedUpdates 方法
  ReactUpdates.batchedUpdates(
    batchedMountComponentIntoNode,
    componentInstance,
    container,
    shouldReuseMarkup,
    context
  );
}
```
>这段代码是在首次渲染组件时会执行的一个方法，可以看到它内部调用了一次 `batchedUpdates` 方法（将 `isBatchingUpdates` 设为 true），这是因为在组件的渲染过程中，会按照顺序调用各个生命周期(钩子)函数。如果在函数里面调用 `setState`，则看下列代码


### React 合成事件

当我们在组件上绑定了事件之后，事件中也有可能会触发 setState。为了确保每一次 setState 都有效，React 同样会在此处手动开启批量更新。看下面代码：

```
// ReactEventListener.js

dispatchEvent: function (topLevelType, nativeEvent) {
  try {
    // 处理事件：batchedUpdates会将 isBatchingUpdates设为true
    ReactUpdates.batchedUpdates(handleTopLevelImpl, bookKeeping);
  } finally {
    TopLevelCallbackBookKeeping.release(bookKeeping);
  }
}
```

`isBatchingUpdates` 这个变量，在 React 的生命周期函数以及合成事件执行前，已经被 React 改为 true，这时我们所做的 setState 操作自然不会立即生效。当函数执行完毕后，事务的 close 方法会再把 isBatchingUpdates 改为 false。

### batchedUpdates 方法

看到这里大概就可以了解 setState 的同步异步机制了，接下来让我们进一步体会，可以把 React 的`batchedUpdates`拿来试试，在该版本中此方法名称被置为`unstable_batchedUpdates `即不稳定的方法。

```
import React, { Component } from 'react'
import { unstable_batchedUpdates as batchedUpdates } from 'react-dom'

class App extends Component {
  state = {
    count: 1,
  }

  handleClick = () => {
    this.setState({
      count: this.state.count + 1,
    })
    console.log(this.state.count) // 1

    this.setState({
      count: this.state.count + 1,
    })
    console.log(this.state.count) // 1

    setTimeout(() => {
      batchedUpdates(() => {
        this.setState({
          count: this.state.count + 1,
        })
        console.log(this.state.count) // 2
      })
    })
  }
  render() {
    return (
      <>
        <button onClick={this.handleClick}>加1</button>
        <div>{this.state.count}</div>
      </>
    )
  }
}

export default App
```

如果调用`batchedUpdates`方法，则 `isBatchingUpdates`变量会被设置为 true，由上述得为 true 走的是批量更新策略，则 setTimeout 里面的方法也变成异步更新了，所以最终打印值为 2，与本文第一道题结果一样。

## fiber架构的更新机制待续

## 总结
>`isBatchingUpdates` 是一个 react 全局唯一的变量，初始值是 `false`，意味着“当前并未进行任何批量更新操作”，每当 `React` 去执行更新动作时，会将 `isBatchingUpdates` 置为 `true`，表示现在正处于批量更新过程中。置为 true 时，任何需要更新的组件都只能暂时进入 `dirtyComponents` 里排队等候下一次的批量更新。 `isBatchingUpdates` 这个变量，在` React` 的生命周期函数以及合成事件执行前，已经被 `React` 悄悄修改为了 `true`，这时我们所做的 `setState` 操作自然不会立即生效。当函数执行完毕后，事务的 `close` 方法会再把 `isBatchingUpdates` 改为 `false`。 因为 `isBatchingUpdates` 是在同步代码中变化的，而 `setTimeout` 的逻辑是异步执行的。当 `this.setState` 调用真正发生的时候，`isBatchingUpdates` 早已经被重置为了 `false`，这就使得当前场景下的 `setState` 具备了立刻发起同步更新的能力。

## 参考文档
[深入 React 的 setState 机制](https://segmentfault.com/a/1190000039077904)

[揭密React setState](https://juejin.cn/post/6844903667426918408)

[setState 是同步还是异步的？](https://juejin.cn/post/6969138101507604516)
